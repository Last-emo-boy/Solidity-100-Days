# Solidity中的数据结构 - 数组和映射

Solidity是一种用于编写智能合约的高级编程语言，它支持多种数据类型和数据结构，用于存储和操作数据。在本文中，我们将介绍两种常用的数据结构：数组和映射。

## 数组

数组是一种有序的数据集合，它可以存储相同类型的元素。数组的长度可以是固定的或者动态的，取决于它是如何定义的。数组可以是一维的或者多维的，也就是说，数组的元素可以是其他数组。

### 定义数组

要定义一个数组，我们需要指定元素的类型和数组的名称，以及可选的长度（如果是固定长度的数组）。例如：

```solidity
// 定义一个固定长度为5的uint类型的数组
uint[5] fixedArray;

// 定义一个动态长度的bool类型的数组
bool[] dynamicArray;

// 定义一个二维的动态长度的bytes32类型的数组
bytes32[][] multiArray;
```

注意，如果我们不指定长度，那么数组就是动态长度的，也就是说，它可以根据需要增加或减少元素。另外，如果我们想要定义一个多维数组，我们需要在每个维度后面加上一个方括号。

### 访问和修改数组

要访问或修改数组中的元素，我们需要使用方括号和索引（从0开始）来指定位置。例如：

```solidity
// 给fixedArray中第一个元素赋值为1
fixedArray[0] = 1;

// 获取dynamicArray中第三个元素的值
bool value = dynamicArray[2];

// 给multiArray中第二个元素（也是一个数组）添加一个新元素
multiArray[1].push("Hello");
```

注意，对于动态长度的数组，我们可以使用`push`方法来在末尾添加一个新元素，或者使用`pop`方法来删除末尾的元素。例如：

```solidity
// 给dynamicArray添加一个新元素true
dynamicArray.push(true);

// 删除dynamicArray中最后一个元素
dynamicArray.pop();
```

另外，对于任何类型的数组，我们可以使用`length`属性来获取它的长度（元素个数）。例如：

```solidity
// 获取fixedArray的长度
uint fixedLength = fixedArray.length;

// 获取dynamicArray的长度
uint dynamicLength = dynamicArray.length;

// 获取multiArray中第一个元素（也是一个数组）的长度
uint subLength = multiArray[0].length;
```

### 数组作为函数参数和返回值

我们可以将数组作为函数的参数或返回值，但是我们需要注意一些细节。首先，如果我们想要传递一个固定长度的数组作为参数或返回值，我们需要在类型后面加上长度。例如：

```solidity
// 定义一个接受固定长度为3的uint类型数组作为参数，并返回该数组第一个元素加上第二个元素的函数
function add(uint[3] memory array) public pure returns (uint) {
    return array[0] + array[1];
}
```

注意，在这里我们使用了`memory`关键字来指定参数是存储在内存中还是存储区中。这是因为Solidity有两种不同的数据位置：内存和存储区。内存是临时的，用于函数调用期间存储数据；存储区是永久性的，用于智能合约状态变量存储数据。通常情况下，函数参数和返回值都应该使用内存位置。

其次，如果我们想要传递一个动态长度或多维的数组作为参数或返回值，我们需要在类型后面加上`calldata`关键字。这是因为动态长度或多维的数组在内存中占用空间不确定，所以不能直接复制到内存中。而`calldata`是一种特殊的数据位置，它只能用于外部函数（被其他合约或用户调用）的参数或返回值，并且只能读取不能修改。例如：

```solidity
// 定义一个接受动态长度或多维字符串类型数组作为参数，并返回该数组第一个元素拼接上"World"字符串作为结果字符串类型数组（只有一个元素）的函数
function concat(string[] calldata array) external pure returns (string[] memory) {
    string[] memory result = new string[](1); // 创建一个动态长度为1的字符串类型内存数组
    result[0] = string(abi.encodePacked(array[0], "World")); // 拼接字符串并赋值给结果数组第一个元素
    return result; // 返回结果数组
}
```

注意，在这里我们使用了`external`关键字来指定函数是外部函数，并且使用了`abi.encodePacked`方法来将两个字符串连接起来。

## 映射

映射是一种无序的键值对集合，它可以将任意类型（除了映射、动态长度或多维数组、合约、枚举、结构体等复杂类型）作为键（key），将任意类型（包括复杂类型）作为值（value）。映射可以实现高效地根据键查找或修改值。

### 定义映射

要定义一个映射，我们需要指定键和值得类型以及映射得名称。例如：

```solidity
// 定义一个将地址映射到uint类型得映射
mapping(address => uint) balance;

// 定义一个将string映射到bool类型得映射
mapping(string => bool) isRegistered;

// 定义一个将uint映射到动态长度得bytes32类型得数组得映射
mapping(uint => bytes32[]) data;
```

注意，在这里我们使用了箭头符号（=>）来表示键和值得对应关系。

### 访问和修改映射

要访问或修改映射中得值，我们需要使用方括号和键来指定位置。例如：

```solidity
// 给balance中当前合约地址对应得值赋值为1000
balance[address(this)] = 1000;

// 获取isRegistered中"Bob"对应得值
bool status = isRegistered["Bob"];

// 给data中1对应得值（也是一个数组）添加一个新元素
data[1].push("Hello");
```

注意，在这里我们使用了`address(this)`来获取当前合约地址。

### 映射作为函数参数和返回值

我们不能将映射作为函数得参数或返回值传递，因为映射本身并不占用空间，而只是通过哈希函数计算出键对应得存储区位置。如果我们想要传递映射中得某个值作为参数或返回值，我们需要先通过键访问到该值，并且指定正确得数据位置。例如：

```solidity
// 定义一个接受balance中当前合约地址对应得值作为参数，并返回该值乘以2得结果得函数
function double(uint memory amount) public view returns (uint) {
    return amount * 2;
}

// 调用该函数时传递balance中当前合约地址对应得值作为参数
uint result = double(balance[address(this)]);
```

注意，在这里我们使用`memory`关键字来指定参数是存储在内存中的，因为我们只是传递一个值，而不是一个引用。另外，我们使用了`view`关键字来指定函数是只读的，不会修改合约状态。

## 数组和映射的比较

数组和映射都是常用的数据结构，它们各有优缺点。下面我们来比较一下它们的特点：

- 数组是有序的，映射是无序的。这意味着数组可以通过索引访问或遍历元素，而映射只能通过键访问或遍历值。
- 数组可以存储任意类型的元素，映射只能将简单类型作为键，而可以将任意类型作为值。这意味着数组可以实现更复杂的数据结构，而映射可以实现更高效的查找或修改操作。
- 数组可以是固定长度或动态长度的，映射只能是动态长度的。这意味着数组可以根据需要分配或释放空间，而映射只能增加空间，不能减少空间。
- 数组可以是一维的或多维的，映射只能是一维的。这意味着数组可以表示更高维度的数据，而映射只能表示键值对的关系。
- 数组可以作为函数参数或返回值传递（需要注意数据位置和长度），映射不能作为函数参数或返回值传递（只能传递映射中的某个值）。这意味着数组可以在函数之间共享数据，而映射只能在合约内部使用。

## 数组和映射的高级用法

除了基本的用法外，数组和映射还有一些高级的用法，我们在这里简单介绍一下。

### 数组切片

数组切片是一种从数组中获取一部分元素的操作，它可以使用冒号（:）和索引来指定开始和结束的位置。例如：

```solidity
// 定义一个动态长度的uint类型的数组
uint[] numbers = [1, 2, 3, 4, 5];

// 获取数组中从第二个元素（包含）到第四个元素（不包含）的切片
uint[] slice = numbers[1:3]; // slice = [2, 3]

// 获取数组中从第一个元素（包含）到最后一个元素（包含）的切片
uint[] copy = numbers[:]; // copy = [1, 2, 3, 4, 5]

// 获取数组中从倒数第二个元素（包含）到倒数第一个元素（不包含）的切片
uint[] tail = numbers[-2:-1]; // tail = [4]
```

注意，数组切片返回的是一个新的内存数组，它不会修改原始数组。另外，如果索引超出范围，会抛出异常。

### 映射迭代器

映射迭代器是一种遍历映射中所有键值对的操作，它可以使用`for`循环和`key`、`value`关键字来实现。例如：

```solidity
// 定义一个将地址映射到uint类型的映射
mapping(address => uint) balance;

// 给映射中添加一些键值对
balance[0x123] = 100;
balance[0x456] = 200;
balance[0x789] = 300;

// 使用映射迭代器遍历映射中所有键值对，并打印它们
for (address key : balance) {
    uint value = balance[key];
    console.log(key, value);
}
```

注意，映射迭代器只能用于只读的操作，不能用于修改或删除映射中的键值对。另外，映射迭代器遍历的顺序是不确定的，不能保证按照插入或排序的顺序。
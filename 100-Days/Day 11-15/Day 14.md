# 合约的布局和状态变量的存储

## 什么是合约的布局和状态变量的存储？

合约的布局和状态变量的存储是指合约中定义的状态变量（即在合约内部但不在函数内部声明的变量）如何在区块链上的存储中被组织和分配的规则。状态变量是合约的长期存储数据，它们可以在函数或事务执行完成后保留其值。理解这些规则对于编写高效、安全和可升级的合约非常重要。

## 合约的存储是如何组织的？

每个合约都有自己的存储区域，这是一个持久的、可读写的内存区域。合约只能从自己的存储区读取和写入。合约的存储被分成 2 个 32 字节大小的槽位（slot）。槽位是连续的，由索引引用，从 0 开始，到 2²⁵⁶ 结束。所有槽位都初始化为 0。

EVM 存储器只能直接访问这些 32 字节大小的槽位。由于存储容量巨大，合约的存储可以被认为是虚拟的。这意味着，如果读取一个随机槽位，它很可能为空/未初始化。读取这样的槽位将返回一个值为 0。EVM 实际上并没有存储所有这些 0，但它会跟踪哪些槽位正在使用，哪些没有。当访问一个未使用的槽位时，EVM 知道并将返回 0。

## 状态变量是如何映射到存储槽中的？

Solidity 将自动将合约定义的每个状态变量映射到存储槽中，按照声明状态变量的顺序，从槽 0 开始。例如，如果有以下合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.4.0 <0.9.0;

contract Example {
    uint256 a; // slot 0
    uint32 b; // slot 1
    bool c; // slot 2
}
```

那么变量 `a` 将被分配到槽 0，变量 `b` 将被分配到槽 1，变量 `c` 将被分配到槽 2。

## 状态变量是如何填充和打包到存储槽中的？

为了将需要少于 32 字节内存的变量存储在存储器中，EVM 将使用 0 填充值，直到使用了所有 32 字节的槽，然后存储填充值。许多变量类型比 32 字节的槽大小要小，例如：`bool`，`uint8`，`address`。例如，在上面的合约中：

- 变量 `a` 的类型是 `uint256`，它正好占用一个完整的槽。
- 变量 `b` 的类型是 `uint32`，它只占用一个槽中的前四个字节。剩下的 28 个字节将被填充为 0。
- 变量 `c` 的类型是 `bool`，它只占用一个槽中的第一个位（bit）。剩下的 255 个位将被填充为 0。

如果有多个小于 32 字节的变量，Solidity 将尝试将它们打包到同一个槽中，以节省存储空间。打包的规则是：

- 变量按照声明的顺序从低位到高位打包。
- 如果一个变量不能完全放入当前槽中，它将被移动到下一个槽中。
- 结构体和数组总是占用一个完整的槽，即使它们可以被打包。
- 映射总是占用一个完整的槽，并且不会与其他变量打包。

例如，如果有以下合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.4.0 <0.9.0;

contract Example {
    uint64 a; // slot 0
    uint32 b; // slot 0
    bool c; // slot 0
    uint8 d; // slot 1
    uint256 e; // slot 2
    struct S {
        uint8 f;
        uint16 g;
    }
    S s; // slot 3
    mapping (uint => uint) m; // slot 4
}
```

那么变量 `a`，`b` 和 `c` 将被打包到槽 0 中，变量 `d` 将被分配到槽 1 中，变量 `e` 将被分配到槽 2 中，结构体 `s` 将被分配到槽 3 中，映射 `m` 将被分配到槽 4 中。槽 0 的布局如下：

| 槽位 | 偏移 | 变量 | 类型 | 大小 |
| --- | --- | --- | --- | --- |
| 0 | 0 - 63 | a | uint64 | 64 bits |
| 0 | 64 - 95 | b | uint32 | 32 bits |
| 0 | 96 - 96 | c | bool | 1 bit |
| 0 | 97 - 255 | - | - | padding |

## 如何访问和修改状态变量？

可以在合约中的任何函数或修饰器中使用状态变量的名称来访问或修改它们。例如：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.4.0 <0.9.0;

contract Example {
    uint256 a; // slot 0

    function getA() public view returns (uint256) {
        return a; // read from storage slot 0
    }

    function setA(uint256 _a) public {
        a = _a; // write to storage slot 0
    }
}
```

也可以在合约外部通过调用合约的函数或使用合约的 ABI 来访问或修改状态变量。例如，如果有以下合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.4.0 <0.9.0;

contract Counter {
    uint256 public count; // slot 0

    function increment() public {
        count++; // increase count by one
    }
}
```

那么可以通过以下方式来访问或修改 `count` 变量：

- 在合约内部，可以直接使用 `count` 的名称来读取或写入它。
- 在合约外部，可以调用 `increment()` 函数来增加 `count` 的值。
- 在合约外部，可以调用 `count()` 函数（由 Solidity 自动生成）来读取 `count` 的值。
- 在合约外部，可以使用合约的 ABI 来编码或解码存储槽的数据。

好的，我将继续写下去。

## 如何处理复杂的状态变量类型？

如果状态变量是复杂的类型，例如结构体，数组或映射，那么它们在存储中的布局和访问方式会有所不同。这些类型通常需要多个槽位来存储它们的数据，或者使用一些哈希函数来计算它们的存储位置。以下是一些常见的复杂类型的存储规则：

- 结构体：结构体是一种用户定义的类型，它可以包含多个不同类型的变量。结构体总是占用一个完整的槽位，即使它们可以被打包。结构体中的变量按照声明的顺序被打包到结构体的槽位中，遵循上面提到的打包规则。如果结构体中有一个变量是数组或映射，那么它将被视为一个指针，指向另一个槽位，而不是直接存储在结构体中。例如，如果有以下合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.4.0 <0.9.0;

contract Example {
    struct S {
        uint8 a;
        uint16 b;
        uint256[] c;
        mapping (uint => uint) d;
    }
    S s; // slot 0
}
```

那么结构体 `s` 将被分配到槽 0 中，变量 `a` 和 `b` 将被打包到槽 0 中，变量 `c` 将被视为一个指针，指向槽 1 中存储的数组，变量 `d` 将被视为一个指针，指向槽 2 中存储的映射。槽 0 的布局如下：

| 槽位 | 偏移 | 变量 | 类型 | 大小 |
| --- | --- | --- | --- | --- |
| 0 | 0 - 7 | a | uint8 | 8 bits |
| 0 | 8 - 23 | b | uint16 | 16 bits |
| 0 | 24 - 255 | - | - | padding |

- 数组：数组是一种可以存储相同类型元素的集合。数组可以是动态长度（长度可以在运行时改变）或静态长度（长度在编译时确定）。数组总是占用一个完整的槽位，即使它们可以被打包。数组中的元素按照索引顺序被打包到数组的槽位中，遵循上面提到的打包规则。如果数组中有一个元素是数组或映射，那么它将被视为一个指针，指向另一个槽位，而不是直接存储在数组中。动态长度数组在第一个槽位中存储它们的长度（用 uint256 表示），然后从第二个槽位开始存储它们的元素。静态长度数组不需要存储它们的长度，因为它们在编译时已经确定。例如，如果有以下合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.4.0 <0.9.0;

contract Example {
    uint256[] a; // slot 0
    bool[3] b; // slot 1
    uint8[2][] c; // slot 2
}
```

那么数组 `a` 将被分配到槽 0 中，第一个槽位存储它的长度（假设为 n），从第二个槽位开始存储它的元素（假设为 a[0] 到 a[n-1]）。数组 `b` 将被分配到槽 1 中，第一个槽位存储它的三个元素（假设为 b[0]，b[1] 和 b[2]）。数组 `c` 将被分配到槽 2 中，第一个槽位存储它的长度（假设为 m），从第二个槽位开始存储它的元素（假设为 c[0] 到 c[m-1]）。每个元素都是一个长度为 2 的 uint8 数组，它们将被打包到一个槽位中。槽 0，1 和 2 的布局如下：

| 槽位 | 偏移 | 变量 | 类型 | 大小 |
| --- | --- | --- | --- | --- |
| 0 | 0 - 255 | a.length | uint256 | 256 bits |
| 1 | 0 - 2 | b[0] - b[2] | bool[3] | 3 bits |
| 1 | 3 - 255 | - | - | padding |
| 2 | 0 - 255 | c.length | uint256 | 256 bits |

- 映射：映射是一种可以存储键值对的集合。映射可以是任意长度，只要有足够的存储空间。映射总是占用一个完整的槽位，即使它们可以被打包。映射中的键值对不是按照索引顺序被打包到映射的槽位中，而是使用一个哈希函数来计算它们的存储位置。哈希函数的公式是：

```solidity
keccak256(abi.encodePacked(key, p))
```

其中 `key` 是映射的键，`p` 是映射所在的槽位。这个公式将返回一个哈希值，它将作为键值对所在的槽位。如果映射中有一个值是数组或映射，那么它将被视为一个指针，指向另一个槽位，而不是直接存储在映射中。例如，如果有以下合约：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.4.0 <0.9.0;

contract Example {
    mapping (uint => uint) a; // slot 0
    mapping (address => bool) b; // slot 1
    mapping (bytes32 => uint[]) c; // slot 2
}
```

那么映射 `a` 将被分配到槽 0 中，映射 `b` 将被分配到槽 1 中，映射 `c` 将被分配到槽 2 中。假设想要访问或修改以下键值对：

- `a[1] = 42`
- `b[0x1234...] = true`
- `c[keccak256("hello")] = [1,2,3]`

那么计算它们所在的槽位：

- `a[1]` 的槽位是 `keccak256(abi.encodePacked(1, 0))`
- `b[0x1234...]` 的槽位是 `keccak256(abi.encodePacked(0x1234..., 1))`
- `c[keccak256("hello")]` 的槽位是 `keccak256(abi.encodePacked(keccak256("hello"), 2))`

注意：由于哈希函数的性质，不同的键可能会产生相同的哈希值，这就导致了存储冲突。这种情况非常罕见，但如果发生了，可以通过修改键或映射所在的槽位来解决。

## 如何优化状态变量的存储？

由于存储是区块链上最昂贵的资源之一，优化状态变量的存储可以节省 gas 费用，提高合约性能，增强合约安全性。以下是一些优化状态变量存储的建议：

- 尽量使用较小的数据类型，例如 `uint8` 而不是 `uint256`，如果不需要那么多的位数。
- 尽量将较小的数据类型打包到同一个槽位中，以减少存储空间的浪费。
- 尽量避免使用动态长度的数组或映射，因为它们会占用更多的存储空间，并且需要更多的计算来访问它们。
- 尽量使用内存或栈上的变量来处理临时数据，而不是将它们存储在存储中。
- 尽量删除不再需要的状态变量，以释放存储空间，并且可以获得 gas 的退款。
